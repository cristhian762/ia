# -*- coding: utf-8 -*-
"""IA-GeneticAlgorithm-8queens-Solucao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N6lVlrffNY3Gy_yDupReT50MRZfVHGqt

Teste de implementação em phyton do Algoritmo Genético.
Obs.:

# Algoritmo Genético
## Para o problema das 8 rainhas

## Importações
"""

# Manipulação de dados
import numpy as np
#import pandas as pd

# Geração de números aleatórios
import random

#VT = np.array([4,8,2,7,3,1,5,6])
VT = np.array([4,8,2,7,3,7,5,4])

VT

"""## Funções Auxiliares - Problema

### Converte Vetor em Tabuleiro
"""

def converte_tabuleiro(VT):
    '''
    Recebe um vetor representando um tabuleiro
    com N rainhas, uma por coluna e retorna
    uma lista de lista de 0 e 1 representando
    um tabuleiro com as rainhas.
    '''
    N = len(VT)

    L = [0]*N
    T = []
    for i in range(N):
        T += [L.copy()]

    for lin in range(N):
        for col in range(N):
            if lin+1 == VT[col]:
                T[lin][col] = 1

    return T

converte_tabuleiro(VT)

"""### Calcula custo (Fitness)"""

def __conta_ataques_linhas(VT):
    '''
    Função que recebe um Vetor-Tabuleiro e
    retorna o número de pares de rainhas se
    atacando mutuamente nas linhas.
    '''
    ataques = 0
    N = len(VT)
    for col1 in range(N):
        lin1 = VT[col1]
        for col2 in range(col1+1, N):
            lin2 = VT[col2]
            if lin1==lin2:
                ataques +=1

    return ataques

__conta_ataques_linhas(VT)

def __conta_ataques_diagonais(VT):
    '''
    Função que recebe um Vetor-Tabuleiro e
    retorna o número de pares de rainhas se
    atacando mutuamente nas diagonais.
    '''
    ataques = 0
    N = len(VT)

    for col1 in range(N):
        lin1 = VT[col1]
        for col2 in range(col1+1, N):
            lin2 = VT[col2]

            # diferenças entre as linhas e colunas
            d1 = lin1-col1
            d2 = lin2-col2

            # somas das linhas e colunas
            s1 = lin1+col1
            s2 = lin2+col2

            # condições para ataques nas diagonais
            if d1==d2 or s1==s2:
                ataques +=1
                #print(f'({lin1},{col1+1}) ({lin2},{col2+1}) -->', ataques,
                #      '<--', f'  -({d1:2},{d2:2})  +({s1:2},{s2:2})')

    return ataques

converte_tabuleiro(VT)

__conta_ataques_diagonais(VT)

def conta_ataques(VT):
    '''
    Função que recebe um Vetor-Tabuleiro e
    retorna o número de pares de rainhas se
    atacando mutuamente nas linhas e diagonais.
    '''
    ataques  = __conta_ataques_linhas(VT)

    ataques += __conta_ataques_diagonais(VT)

    return ataques

VT = [1,2,3,4,5,6,7,8]

conta_ataques(VT)

"""### Gera vizinhos"""

def gera_vizinhos(VT):
    '''
    Gera todos os vizinhos possíveis,
    variando uma rainha de cada vez.
    '''
    N = len(VT)
    for col in range(N):
        for lin in range(N):
            # se nao existe rainha naquela linha,
            # entao gera estado vizinho.
            linha = lin+1
            if linha != VT[col]:
                vizinho   = VT.copy()
                vizinho[col] = linha

                yield vizinho

"""### Gera tuplas custos"""

def gera_tuplas_custos(Populacao):
    '''
    Gera tuplas com os custos de todos os individuos da populacao.
    '''
    TuplasCustos = []
    for individuo in Populacao:
        ataques = conta_ataques(individuo)

        TuplasCustos += [(ataques, individuo)]

    return TuplasCustos

Populacao = gera_vizinhos(VT)
Tuplas = gera_tuplas_custos(Populacao)
Tuplas

sorted(Tuplas, key=lambda k: k[0])

"""## Funções Auxiliares - AG

### Mutação
"""

def mutacao(VT, p_mutacao=0.30):

    VT_mutated = VT.copy()

    N = len(VT)
    p = np.random.rand()

    if p < p_mutacao:
        col   = np.random.randint(0,N)    # indice da coluna (base-0)
        linha = np.random.randint(1,N+1)  # valor da linha   (base-1)

        VT_mutated[col] = linha
        #print(col+1, linha)

    return VT_mutated

VT2 = mutacao(VT)
VT, VT2, VT != VT2

"""### Crossover"""

def crossover(Parent1, Parent2):

    N = len(Parent1)

    # ponto de corte
    c = np.random.randint(1, N-1)

    # crossover no ponto de corte
    # gerando dois filhos
    child1 = Parent1[:c] + Parent2[c:]
    child2 = Parent2[:c] + Parent1[c:]

    return child1, child2

VT1 = [1,1,1,1,1,1,1,1]
VT2 = [2,2,2,2,2,2,2,2]

crossover(VT1,VT2)

"""### Seleciona pais"""

def selecao(Populacao):
    Candidato1 = random.choice(Populacao)
    Candidato2 = random.choice(Populacao)

    a1 = conta_ataques(Candidato1)
    a2 = conta_ataques(Candidato2)
    #print(a1,a2)

    # eleito o candidato com menor custo
    eleito = Candidato1 if a1<=a2 else Candidato2

    return eleito

selecao([VT1,VT2])

"""### Gera Indivíduo"""

def gera_individuo(n_cols):
    # individuo é um Vetor (N) em que cada posicação
    # representa uma coluna indicando as respectivas
    # linhas ocupadas pelas rainhas em um tabuleiro (NxN).

    # VT = [low, high) x n_cols

    VT = np.random.randint(low=1, high=n_cols+1, size=n_cols)
    return VT

N=8
gera_individuo(N)

"""### Gera População"""

def gera_populacao_inicial(N, tam_pop):
    # N:       tamanho do tabuleiro (NxN)
    # tam_pop: tamanho da população
    populacao = []
    for _ in range(tam_pop):
        individuo = gera_individuo(N)

        populacao.append(individuo)

    return populacao



"""## Algoritmo Genético - Implementação"""

# 1) Randomly initialize populations p
# 2) Compute fitness of population
# 3) Until convergence repeat:
#       a) Select parents from population
#       b) Crossover and generate new population
#       c) Perform mutation on new population
#       d) Calculate fitness for new population

def algoritmo_genetico():
    # pseudo-código:

    # START
    N = 8
    tam_pop = 10
    fitness = gera_tuplas_custos # função fitness

    # Generate the initial population
    Populacao = gera_populacao_inicial(N, tam_pop)

    # Compute fitness - apenas em caso de elitismo
    #custosPopulacao = fitness(Populacao)

    # REPEAT
    while (True):
        #     Selection
        selecao(Populacao)
        #     Crossover
        #     Mutation
        #     Compute fitness
        # UNTIL population has converged
    # STOP

    # coloque seu código aqui
    pass